"""
Script to find the tune; drives xboa DPhiTuneFinder (FFT was making large side
bands which looked non-physical)
"""

import glob
import json
import sys
import math
import os
import shutil
import matplotlib

from opal_tracking import OpalTracking
import xboa.common as common
from xboa.hit import Hit
from xboa.algorithms.tune import FFTTuneFinder
from xboa.algorithms.tune import DPhiTuneFinder
from utils import utilities

class TuneFinder(object):
    def __init__(self, config):
        """
        Find the tune. 

        -probe_file_name: name of a PROBE file from OPAL output, or None. If file_name
                    is specified, use that file_name in order to calculate tunes
                    (and generate plots), otherwise generate a new one by
                    tracking.
        -closed_orbits_file_name: name of a file containing closed orbits,
                    generated by e.g. 
        """
        self.closed_orbits_cached = None # filled by _load_closed_orbits
        self.tmp_dir = None
        self.unique_id = 1
        self.lattice_src = config.tracking["lattice_file"]
        self.probe_filename = config.find_tune["probe_files"]
        co_file = os.path.join(config.run_control["output_dir"],
                               config.find_closed_orbits["output_file"])
        self._load_closed_orbits(co_file)
        self.delta_x = config.find_tune["delta_x"]
        self.delta_y = config.find_tune["delta_y"]
        self.row = config.find_tune["row_list"]
        self.do_axis = config.find_tune["axis"]
        self.opal = config.tracking["opal_path"]
        self.step_size = config.tracking["step_size"]
        self.config = config

        self.lattice = "/SectorFFAGMagnet.tmp"
        self.beam_file = "/disttest.dat"
        self.log_file = "/log"
        self.output_dir = config.run_control["output_dir"]
        self.output_filename = os.path.join(self.output_dir,
                                            config.find_tune["output_file"])
        self.plot_dir = os.path.join(self.output_dir, "find_tune")
        utilities.clear_dir(self.plot_dir)


    def find_tune_dphi(self):
        """
        Algorithm is to just calculate the turn-by-turn phase advance; this is
        done by evolving turn-by-turn the track; calculating a matched ellipse
        by looking at tracking output; transforming the ellipse into a circle
        using LU decomposition; then calculating the angle advanced.
        """
        cwd = os.getcwd()
        fout = open(self.output_filename, "w")
        index = 0
        for i, closed_orbit in enumerate(self.closed_orbits_cached):
            if self.row != None and i not in self.row:
                continue
            if len(closed_orbit["hits"]) == 0:
                print("Error - no closed orbit")
                continue
            index += 1
            subs = closed_orbit["substitutions"]
            for item, key in self.config.find_tune["subs_overrides"].items():
                subs[item] = key

            print("Finding tune with", end=' ') 
            for key in sorted(subs.keys()):
                print(utilities.sub_to_name(key), subs[key], end=' ')
            print()
            tune_info = {"substitutions":subs}
            for axis1, axis2, delta1, delta2 in [("x", "px", self.delta_x, 0.),
                                                 ("y", "py", self.delta_y, 0.)]:
                if self.do_axis != None and axis1 != self.do_axis:
                    continue
                hit = Hit.new_from_dict(closed_orbit["hits"][0])
                self._temp_dir()
                common.substitute(
                    self.lattice_src, 
                    self.tmp_dir+self.lattice,
                    subs)
                tracking = OpalTracking(self.tmp_dir+self.lattice,
                                        self.tmp_dir+self.beam_file,
                                        self._reference(hit),
                                        self.probe_filename,
                                        self.opal,
                                        self.tmp_dir+self.log_file)
                tracking.clear_path = self.tmp_dir+"/*.loss"
                finder = DPhiTuneFinder()
                try:
                    finder.run_tracking(axis1, axis2, delta1, delta2, hit, tracking)
                except RuntimeError:
                    sys.excepthook(*sys.exc_info())
                for track_index, track in enumerate(tracking.last):
                    print('Track', track_index, 'of', len(tracking.last), \
                          'with', len(track), 'hits')
                finder.u = finder.u[1:]
                finder.up = finder.up[1:]
                try:
                    tune = finder.get_tune(subs["__n_turns__"]/10.)
                except:
                    tune = 0.
                print('  Found', len(finder.dphi), 'dphi elements with tune', tune, "+/-", finder.tune_error)
                tune_info[axis1+"_tune"] = tune
                tune_info[axis1+"_tune_rms"] = finder.tune_error
                tune_info[axis1+"_signal"] = list(zip(finder.u, finder.up))
                tune_info[axis1+"_dphi"] = finder.dphi
                tune_info[axis1+"_n_cells"] = len(finder.dphi)
                self.do_plots(i, axis1, axis2, finder)
                for i, u in enumerate([]):#finder.u[:-1]):
                    up = finder.up[i]
                    dphi = finder.dphi[i]
                    t = finder.t[i]
                    u_chol = finder.point_circles[i][0]
                    up_chol = finder.point_circles[i][1]
                    phi = math.atan2(up_chol, u_chol)
                    print(str(i).ljust(4),  str(round(t, 4)).rjust(8), "...", \
                          str(round(u, 4)).rjust(8), str(round(up, 4)).rjust(8), "...", \
                          str(round(u_chol, 4)).rjust(8), str(round(up_chol, 4)).rjust(8), "...", \
                          str(round(phi, 4)).rjust(8), str(round(dphi, 4)).rjust(8))

            for key in sorted(tune_info.keys()):
                if "signal" not in key and "dphi" not in key:
                    print("   ", key, tune_info[key])
            print(json.dumps(tune_info), file=fout)
            fout.flush()
        os.chdir(cwd)

    def do_plots(self, i, axis1, axis2, finder):
        fig_index = finder.plot_phase_space_matplotlib("%s [mm]"%axis1, "%s [MeV/c]"%axis2)
        name = os.path.join(self.plot_dir,
                            "tune_"+str(i)+"_"+axis1+"_phase-space")
        fig = matplotlib.pyplot.figure(fig_index)
        for format in ["png",]:
            fig.savefig(name+"."+format)
        matplotlib.pyplot.close(fig_index)

        fig_index = finder.plot_cholesky_space_matplotlib()
        name = os.path.join(self.plot_dir,
                            "tune_"+str(i)+"_"+axis1+"_cholesky-space")
        fig = matplotlib.pyplot.figure(fig_index)
        for format in ["png",]:
            fig.savefig(name+"."+format)
        matplotlib.pyplot.close(fig_index)

    def _temp_dir(self):
        """Make a temporary directory for tune calculation"""
        tmp_dir = os.path.join(self.output_dir, self.config.find_tune["run_dir"])
        try:
            os.makedirs(tmp_dir)
        except OSError:
            pass
        os.chdir(tmp_dir)
        self.tmp_dir = "./"

    def _load_closed_orbits(self, filename):
        """Load closed orbits from a json file"""
        fin = open(filename)
        closed_orbits = [json.loads(line) for line in fin.readlines()]
        self.closed_orbits_cached = closed_orbits

    def _reference(self, hit):
        """Generate a reference particle"""
        hit = hit.deepcopy()
        hit["x"] = 0.
        hit["px"] = 0.
        return hit

def main(config):
    tune = TuneFinder(config)
    tune.find_tune_dphi()

if __name__ == "__main__":
    main()










